<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Web Components</title>
		<style>
			body {
				max-width: 100%;
				min-height: 500px;
			}
			#elem {
				display: flex;
				height: 200px;
				justify-content: center;
				align-items: center;
			}
		</style>
	</head>
	<body>
		<!-- script to create the component -->
		<script src="./time-formatted.js"></script>
		<script src="./live-timer.js"></script>

		<!-- <script>
			class MyElement extends HTMLElement {
				constructor() {
					super();
					// element created
				}

				connectedCallback() {
					// browser calls this method when the element is added to the document
					// (can be called many times if an element is repeatedly added/removed)
				}

				disconnectedCallback() {
					// browser calls this method when the element is removed from the document
					// (can be called many times if an element is repeatedly added/removed)
				}

				static get observedAttributes() {
					return [
						/* array of attribute names to monitor for changes */
					];
				}

				attributeChangedCallback(name, oldValue, newValue) {
					// called when one of attributes listed above is modified
				}

				adoptedCallback() {
					// called when the element is moved to a new document
					// (happens in document.adoptNode, very rarely used)
				}

				// there can be other element methods and properties
			}
			class TimeFormatted extends HTMLElement {
				// (1)
				render() {
					let date = new Date(
						this.getAttribute('datetime') || Date.now(),
					);

					this.innerHTML = new Intl.DateTimeFormat('default', {
						year: this.getAttribute('year') || undefined,
						month: this.getAttribute('month') || undefined,
						day: this.getAttribute('day') || undefined,
						hour: this.getAttribute('hour') || undefined,
						minute: this.getAttribute('minute') || undefined,
						second: this.getAttribute('second') || undefined,
						timeZoneName:
							this.getAttribute('time-zone-name') || undefined,
					}).format(date);
				}

				// 2
				connectedCallback() {
					if (!this.render) {
						this.render();
						this.rendered = true;
					}
				}

				static get observedAttributes() {
					// (3)
					return [
						'datetime',
						'year',
						'month',
						'day',
						'hour',
						'minute',
						'second',
						'time-zone-name',
					];
				}

				attributeChangedCallback(name, oldValue, newValue) {
					// (4)
					this.render();
				}
			}

			customElements.define('time-formatted', TimeFormatted); // (2)
		</script> -->
		<!-- <time-formatted
			id="elem"
			year="numeric"
			month="long"
			day="numeric"
			hour="numeric"
			minute="numeric"
			second="numeric"
		></time-formatted> -->
		<script>
			// setInterval(() => elem.setAttribute('datetime', new Date()), 1000); // (5)
		</script>
		<live-timer id="timer"></live-timer>
		<!-- summary -->
		<script>
			timer.addEventListener('tick', (event) =>
				console.log(event.detail),
			);
			// autonomous
			class MyElement extends HTMLElement {
				constructor() {
					super(); /* ... */
				}
				connectedCallback() {
					/* ... */
				}
				disconnectedCallback() {
					/* ... */
				}
				static get observedAttributes() {
					return [
						/* ... */
					];
				}
				attributeChangedCallback(name, oldValue, newValue) {
					/* ... */
				}
				adoptedCallback() {
					/* ... */
				}
			}
			// customElements.define('my-element', MyElement);
			/* <my-element> */
			// from a existing element
			class MyButton extends HTMLButtonElement {
				/*...*/
				constructor() {
					super();
					this.addEventListener('click', () => alert('Hello!'));
				}
			}
			// customElements.define('my-button', MyElement, {
			// 	extends: 'button',
			// });
			/* <button is="my-button"> */
		</script>
	</body>
</html>
